# -*- coding: utf-8 -*-
"""cnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oRJENznjZsNIY3pPtORJ-lV2GtI7jCfm
"""

#!apt-get -qq install -y libsm6 libxext6 && pip install -q -U opencv-python



import warnings
warnings.filterwarnings('ignore')

from keras.datasets import mnist
import numpy as np
import keras as keras
import numpy as np
import cv2 as cv2;

from keras.models import Sequential
from keras.layers import Dense,Dropout,Conv2D, MaxPooling2D,Flatten
from keras import optimizers

from keras.utils import np_utils
from keras.models import model_from_json



from sklearn.metrics import precision_score, \
    recall_score, confusion_matrix, classification_report, \
    accuracy_score, f1_score

from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import GridSearchCV
import matplotlib.pyplot as plt
np.random.seed(1) 




def main():

        #Preparing data 

        (X_train,Y_train),(X_test,Y_test)=mnist.load_data()

        X_train = X_train.reshape(X_train.shape[0], 28, 28 , 1).astype('float32')
        X_test = X_test.reshape(X_test.shape[0], 28, 28 , 1).astype('float32')

        X_train = X_train.astype('float32')
        X_test = X_test.astype('float32')
        X_train /= 255
        X_test /= 255

        Y_trainNum=Y_train  # in original number format such as 1,2,3,4,5
        Y_testNum=Y_test # in original number format such as 1,2,3,4,5

        Y_train = np_utils.to_categorical(Y_train)  # in categorical format
        Y_test = np_utils.to_categorical(Y_test)   # in categorical format


        even=[0,2,4,6,8]

        #Converting Train labels from numbers to even/odd
        Y_trainbinary= np.empty(Y_train.shape[0],dtype=object)     
        for idx, item in enumerate(Y_train):                     
              if np.nonzero(item)[0] in even:
                    Y_trainbinary[idx] = 0     # even number
              else:
                    Y_trainbinary[idx] = 1     # odd number

        Y_trainmodel = np_utils.to_categorical(Y_trainbinary)


        #Converting Test labels from numbers to even/odd

        Y_testbinary=np.empty(Y_test.shape[0],dtype=object)
        

        for idx, item in enumerate(Y_test):

              if np.nonzero(item)[0] in even:
                    Y_testbinary[idx] = 0     # even number
              else:
                    Y_testbinary[idx] = 1     # odd number

        Y_testmodel = np_utils.to_categorical(Y_testbinary)

        # Generating Model layers 

        model = Sequential()

        model.add(Conv2D(32, kernel_size=5, input_shape=(28,28,1),activation = 'relu'))

        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        #model.add(Dropout(0.4))

        model.add(Conv2D(64, kernel_size=5,activation = 'relu'))

        model.add(MaxPooling2D(pool_size=(2, 2)))
        model.add(Dropout(0.4))

        model.add(Flatten())
        model.add(Dense(128, activation='relu'))
        model.add(Dropout(0.4))
        model.add(Dense(2, activation='sigmoid'))

        sgd = optimizers.SGD(lr=0.001)
        model.compile(loss='binary_crossentropy',
                      optimizer=sgd,
                      metrics=['accuracy'])

        history=model.fit(X_train, Y_trainmodel, batch_size=128, epochs=5, validation_split=0.08333)

        for key in history.history.keys():
          plt.plot(history.history[key])
        plt.legend(list(history.history.keys()), loc="upper left")
        plt.show()

        score = model.evaluate(X_test, Y_testmodel, verbose=0)
        print('Test loss:', score[0])
        print('Test accuracy:', score[1])



        preds = model.predict_classes(X_test)
       
        preds1 = np_utils.to_categorical(preds)
        #print(preds1[:10])

        print('Accuracy:', accuracy_score(Y_testbinary.astype(int).astype(int),preds))
        print('Recall:', recall_score(Y_testbinary.astype(int), preds))
        print('Precision:', precision_score(Y_testbinary.astype(int), preds))


        # serialize model to JSON
        model_json = model.to_json()
        with open("model.json", "w") as json_file:
            json_file.write(model_json)
        # serialize weights to HDF5
        model.save_weights("model.h5")
        print("Saved model to disk")




if __name__=="__main__":
  
  
  main()

"""# New Section

# New Section
"""


# -*- coding: utf-8 -*-
"""cnn_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1klmePuWKFE8K3CXJtXiBN_wNXn7tCeOf
"""

import warnings
warnings.filterwarnings('ignore')

from keras.datasets import mnist
import numpy as np
import keras as keras
import numpy as np
import cv2 as cv2;

from keras.models import Sequential
from keras.layers import Dense,Dropout,Conv2D, MaxPooling2D,Flatten
from keras import optimizers

from keras.utils import np_utils
from keras.models import model_from_json



from sklearn.metrics import precision_score, \
    recall_score, confusion_matrix, classification_report, \
    accuracy_score, f1_score

from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import GridSearchCV
import matplotlib.pyplot as plt
np.random.seed(1)  



  

def loadandreturnmodel():

        #Preparing data 

        (X_train,Y_train),(X_test,Y_test)=mnist.load_data()

        X_train = X_train.reshape(X_train.shape[0], 28, 28 , 1).astype('float32')
        X_test = X_test.reshape(X_test.shape[0], 28, 28 , 1).astype('float32')

        X_train = X_train.astype('float32')
        X_test = X_test.astype('float32')
        X_train /= 255
        X_test /= 255

        Y_trainNum=Y_train  # in original number format such as 1,2,3,4,5
        Y_testNum=Y_test # in original number format such as 1,2,3,4,5

        Y_train = np_utils.to_categorical(Y_train)  # in categorical format
        Y_test = np_utils.to_categorical(Y_test)   # in categorical format


        even=[0,2,4,6,8]

        #Converting Train labels from numbers to even/odd
        Y_trainbinary= np.empty(Y_train.shape[0],dtype=object)     
        for idx, item in enumerate(Y_train):                     
              if np.nonzero(item)[0] in even:
                    Y_trainbinary[idx] = 0     # even number
              else:
                    Y_trainbinary[idx] = 1     # odd number

        Y_trainmodel = np_utils.to_categorical(Y_trainbinary)


        #Converting Test labels from numbers to even/odd

        Y_testbinary=np.empty(Y_test.shape[0],dtype=object)
       
        for idx, item in enumerate(Y_test):

              if np.nonzero(item)[0] in even:
                    Y_testbinary[idx] = 0     # even number
              else:
                    Y_testbinary[idx] = 1     # odd number

        Y_testmodel = np_utils.to_categorical(Y_testbinary)

        # Generating Model layers 

        model = Sequential()

        model.add(Conv2D(32, kernel_size=5, input_shape=(28,28,1),activation = 'relu'))

        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        #model.add(Dropout(0.4))

        model.add(Conv2D(64, kernel_size=5,activation = 'relu'))

        model.add(MaxPooling2D(pool_size=(2, 2)))
        model.add(Dropout(0.4))

        model.add(Flatten())
        model.add(Dense(128, activation='relu'))
        model.add(Dropout(0.4))
        model.add(Dense(2, activation='sigmoid'))

        sgd = optimizers.SGD(lr=0.001)
        model.compile(loss='binary_crossentropy',
                      optimizer=sgd,
                      metrics=['accuracy'])
        print("******Fitting Model**********")

        history=model.fit(X_train, Y_trainmodel, batch_size=128, epochs=5, validation_split=0.08333)
        print("******Model Fitted and Returning Model**********")
        return model
      
  
def main():
   #print("Training Model First")
   #model=loadandreturnmodel()
  
   print("Loading model from Disk")

   # load json and create model
   json_file = open('model.json', 'r')
   loaded_model_json = json_file.read()
   json_file.close()
   loaded_model = model_from_json(loaded_model_json)
   # load weights into new model
   loaded_model.load_weights("model.h5")
   print("Loaded model from disk")

   print("Model trained and now ready to classify images")
  
   keeprunning=1
    
   while(keeprunning==1):
     response = input("Please enter image path to read or'q' to quit")
     #print("REsponse",response)
     if response == "q":
        keeprunning=0
     else: 
        img = cv2.imread(response)
        img_resize = cv2.resize(img, (28 , 28))
        img_2Predict = cv2.cvtColor(img_resize,cv2.COLOR_BGR2GRAY)
        
        #ADaptivethreshlding
        img_2Predict = cv2.adaptiveThreshold(img_2Predict, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)
        img_2Predict = img_2Predict.reshape(1,28,28,1)
        img_2Predict = img_2Predict.astype('float32')
        img_2Predict/=255
       
        predX = loaded_model.predict_classes(img_2Predict)
        #print(predX)
        if(predX==0):
          print("\nThe number digit in the image is predicted to be EVEN")
        else:
          print("\nThe number digit in the image is predicted to be ODD")
          
   print("\nQuitting Program")
       


if __name__=="__main__":
    main()

#!apt-get -qq install -y libsm6 libxext6 && pip install -q -U opencv-python

